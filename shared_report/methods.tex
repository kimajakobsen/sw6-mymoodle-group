\chapter{Methods}\todo{Vær opmærksom på at dette afsnit nu ligger efter system statement. Valg af dev method skal derfor baseres på at det er godt til at lave vores system}
In this section we describe the development methods and the tools, which are considered to be used in this project.
A choice is given in both of these areas along with a reasoning for the choices.

\section{Development Method}
\label{sec:devMethod}
In this project we are four project groups working together.
For this collaboration to work it is important that we have a common understanding of the development method we are using.
Different development methods are presented here and a single one is chosen to be used in this project.

\subsection{Considered Methods}
We consider some traditional and agile development methods. 
%A common division of development methods is into traditional and agile.
In general, traditional methods follow an upfront planned plan, where every task is handled in a single unit and the result is not changed afterward \cite[sec.~2.7]{Poppendieck00}.
This method is inspired by the construction industry from which it originates.

Projects using agile methods are developed in iterations, where some part of the product is developed in every iteration \cite[p.~25]{Larman04}.
This should help cope with the changes that the end users or customers might pose during the development.

Some methods can have characteristics from both categories.
The development methods considered in this project are: Extreme Programming, Scrum, and Waterfall.
These are presented shortly in the following section.

\subsubsection{Extreme Programming}
Extreme Programming (XP) is an agile development method that consists of a series of 12 recommended core practices \cite[p.~137]{Larman04}.
These include, but are not limited to: Frequent refactoring, pair programming, and the whole team working together in a single room.
The core of XP is to find every practice that is considered good and taking it to the extreme, e.g. since code reviews are good, do them all the time through pair programming.
Kent Beck, the creator of XP, states that in general all the practices of XP should be applied because they compensate and support each other \cite[p.~156-157]{Larman04}.

There are roles assigned to different people involved in the project \cite[p.~145]{Larman04}.
These roles are: Customer, programmer, tester, coach, tracker, and consultant.
All these roles are important, but Larman stresses that an on-site customer or at least an on-site customer proxy is needed \cite[p.~152-156]{Larman04}.

When using XP, the development is to progress in iterations of one to three weeks each.
An iteration should not be planned until right before the start of it.
At the start of the sprint the on-site customer should help prioritize which features should be implemented in the given iteration and the programmers estimate the time to implement them.
This process is called ``Iteration planning game''.

\subsubsection{Scrum}
\label{par:scrum}
Scrum is, as XP, an agile development method that utilizes a number of iterations of development cycles.
These development cycles are known as sprints.
A sprint usually has a length of 30 calendar days~\cite{Larman04}.
A sprint backlog is created prior to the sprint. 
This backlog consists of the features, ordered by priority, that should be implemented during the sprint.
During the sprint the sprint backlog cannot be changed.
If all the features in the sprint backlog are not implemented during the sprint they are moved to the product backlog, which is a list of the features that should be implemented in the future.

In scrum there are different roles. 
There should be a product owner, whose task is to meet the costumer's and end users' interests. 
These interests should be formalized and prioritized in the product backlog.
There is also a scrum master. 
A scrum master serves as a link between the development team and any external individuals.
It is the scrum master's task to ensure that the development team is not disturbed~\cite{Larman04}.
The development team is usually small, and their task is to design, analyze, and implement the features from the backlogs.
Every day the scrum team holds a short meeting where they say what they have done since the preceding meeting, what they plan on doing the present day, and any problems they are having.

A variant of Scrum for more teams is called Scrum of Scrums or Large Scrum.
In such a project there is one complete team consisting of several smaller sub-teams that will hold ongoing Scrum of Scrum meetings during each sprint to synchronize their work.
The Scrum of Scrum meeting is similar to the daily Scrum meeting with a representative from each sub-team, except that they talk about what the sub-teams have done and should do instead of what individuals have done and should do.

\subsubsection{Waterfall}
A project following the Waterfall method is divided into a number of phases.
The number of phases in a Waterfall development process is varies from implementations.
%Depending on the person asked more or less phases may be suggested e.g. Marry Poppendieck\todo{brug evt denne version af waterfall} is referring to six phases; software concept, requirements analysis, architectural design, detailed design, coding and debugging, and system test \cite{Poppendieck00}.
One version of the waterfall model defined at~\citep{Parekh11} divides the waterfall model into six phases:

\begin{itemize}
	\item \textbf{Requirement gathering and analysis} - The initial phase where all possible requirements are gathered from the end-user of the system.
	Their validity and the possibility to implement them is analyzed.
	The result of the phase is a requirement specification document which is used in the next phase.
	\item \textbf{System design} - Based on the requirements a design for the system is constructed. 
	The result is a system design specification document.
	\item \textbf{Implementation and unit testing} - Based on the design document the system is divided into modules and units. 
	The coding is started in this phase. 
	Upon completion every unit is tested.
	\item \textbf{Integration and system testing} - All the developed units are combined into the final system. 
	The integration of the units is tested, and the complete system is tested as well. 
	After a satisfiable number of tests have been conducted the system is delivered to the customer.
	\item \textbf{Deployment} - Depending on the system some initial setup and configuration of the software may be necessary before end-user can use the system. 
	The result of this phase is a deployed system that is set up to the end-user's needs.
	\item \textbf{Operations and maintenance} - A theoretically never-ending phase. 
	After the software is delivered issues may arise from practical use of the software and bugs may be discovered. 
	When issues arise they are dealt with as long as the software is in use.
\end{itemize}

Waterfall models are strictly traditional, since it in its pure form does not allow to move back to a phase once the next is started.
This suggests a big and heavy up-front design plan that is to be followed until the project is finished.

Of the presented methods Waterfall is the method that requires the most documentation.
To complete a phase some document must be created to be used in the following phases.
These documents can vary from an architectural design document to source code.

\section{Choosing a Development Method}
\label{subsec:choosingmethod}
The following list shows the characteristics of this project, which will be used to determine the development method for the project.
\begin{enumerate}
	\item \textbf{Four groups (14 persons in total)} \label{enum:groupSize}\\
	This semester is divided into two major groups, one of which is working with Moodle. 
	This semester has a group limit of four members therefore the Moodle project has been divided into four smaller projects.
	\item \textbf{Diverse target group} \label{enum:targetGroup}\\ 
	The relevant target group is: Students, supervisors, and secretaries/administrative personnel 
	\item \textbf{No on-site costumer} \label{enum:onsite}\\
	Because this is a university project, there are no on-site customers. 
	Instead there are several contact persons such as supervisors, students, and secretaries, which test the product and come with feedback.
	\item \textbf{Hard deadline} \label{enum:deadline}\\
	Because this is a semester project the project must be complete when the semester ends.
	\item \textbf{Pass on project} \label{enum:passed}\\
	This project will be passed on to the students next year.
	\item \textbf{Known framework and platform} \label{enum:framework}\\
	The Moodle platform is open source, and some documentation is available on most relevant topics.
	\item \textbf{Education environment} \label{enum:education}\\
	Since this is a university project, we are working in an educational environment.
	\item \textbf{Not full-time development} \label{enum:halftime}\\
	Because this is a semester project there are also lectures beside the project, therefore the time for development is limited. 
	\item \textbf{No manager/Product owner} \label{enum:manager}\\
	Because this is a semester project, there is no project manager or product owner like there would be in a real working environment.
	\item \textbf{No shared working room} \label{enum:room}\\
	Although this is a multi-project, we are divided in four groups but not located in the same room.
	\item \textbf{Low criticality} \label{enum:criticality}\\
	If the system fails it will affect the comfort of the users.
\end{enumerate}
Barry Boehm and Richard Turn have identified five factors that can be used to determine whether to use a traditional or agile development method \citep{boehmTurner}.
These factors are: Personnel, dynamism, size, culture, and criticality.

The personnel factor covers the composition of personnel based on the \textit{extended Cockburn method skill rating scale}, where people are divided into five categories based on the methodological skills, namely levels -1, 1b, 1a, 2, and 3~\cite[p.~34]{boehmTurner}.
The levels of the extended Cockburn scale are defined as follows:
A person with level -1 is unable or unwilling to follow a shared method.
With training a person with level 1b can perform procedural method steps such as writing a function while conforming to coding standards.
A trained level 1a person is able to perform discretionary method steps such as using design patterns to solve a problem.
A person with level 2 can alter a method to handle a new but similar situation.
A person with the last level, 3, is able to alter a method or create a new one to handle a new unfamiliar situation.

Dynamism is the anticipated percentage of changes in requirements that will occur during the project.
The size is simply the number of people in the development team.
The culture factor is a scale of how much the team prefers chaos over order.
Criticality is a scale of how much a system failure will influence the real world.
This is based on the Cockburn Scale used to differentiate between Crystal methods~\cite{Larman04}.
\todo{find kapitel med crystal methods og lav en præcis reference}
\sharedInput{polar_chart}

A polar chart showing the factors for our project is seen in Figure~\ref{fig:developmentFactors}.
As seen, must of the points are closer to the center than the periphery, this indicates that an agile method is preferred over a traditional one.

The personnel score is positioned in the middle because we consider ourselves above level 1b, but none or very few of us qualify as level 2 or 3.


We will use a development approach similar to Scrum of Scrums.
The reason for this is three-fold.
First of all we have a diverse target group (point \ref{enum:targetGroup}), which may make a big up front analysis and design difficult.
This leads us to choose an agile method due to ``I know it when I see it'' (IKIWISI), that is the customer does not know what she wants before she sees it.
This is also supported by the polar chart showing the development factors in Figure~\ref{fig:developmentFactors}.

Secondly we are 14 members divided into four groups (as point \ref{enum:groupSize} states) which is not handled very well in other agile methods such as XP, which dictates that all the developers should be in the same room. 
This is not the case for us as point \ref{enum:room} states.

The third reason is that we have a hard deadline (point \ref{enum:deadline}), which means that we have to hand in our project at a specific date.
Scrum of Scrums suggests that iterations (sprints) are time-boxed, which is ideal for us since we can cut less important features instead of missing the deadline.
This is also supported by point \ref{enum:passed}, because the end product is a working release although some features may have been cut.
The features cut may then be suggested to the group which is to take up this project next year.


\subsection{Refining SCRUM} 
\label{sub:rescrum}
As point \ref{enum:manager} and \ref{enum:onsite} states, we have neither a project manager nor an available on-site customer.
We will handle the missing on-site customer by having shorter iterations and contacting the customers whenever an iteration is over.
Scrum of Scrums\cite{scrumOfScrums} dictates that there should be a Scrum master in each subgroup.
Since none of us have used Scrum before, none of us are qualified to be a Scrum master.
We are in an educational situation (see point \ref{enum:education}) so we will strive to allow every member to try to be Scrum master for a shorter time period.
This may not be ideal, but we consider it to be more important that every member of the subgroups tries to have the responsibility of a Scrum master than having only one member trying it and learning it well.

%\fixme{Kim: syntes at det skal skrives mere, her er nogle ideer (se comment)}
\begin{comment}
There is more:
*Scrum board
*The phases / meetings
**estimation
**sprint planning
*Scrum meetings
*Scrum of scrum def
*project manager problem
\end{comment}


\section{Tools}\label{subsec:tools}
A series of tools are used in the creation of this project.
These tools are briefly described in this section.
The tools that need to be chosen must complete some task, the tasks that need a tool are: Version control, bug tracking, code documentation, and testing.

\subsection{Version Control}
All of us have been using subversion (SVN) in previous projects as the system for version control.
SVN is a centralized solution \cite{subversion} with a single repository that the group members can update from and commit changes to.
This project does, however, differ from previous project with respect to the organization of groups; we are not one group of $x$ individuals, but rather one group consisting of some smaller subgroups, again consisting of individual persons.
This has lead us to choose a distributed solution rather than a centralized one.

The solutions considered are the distributed systems Git and Mercurial (Hg).
These systems are quite similar and the essential difference is that Hg is simpler than Git and Git is more flexible than Hg \cite{gitVsHg}.
A few of us have been using Hg and none of us have used Git, which leads us to choose Hg, such that we a little knowledge of the chosen system.

\subsection{Bug Tracking}
We need to have some way of communicating and tracking the defects or ``bugs'' that we will run into during our project.
The most important requirement for the tool we will use is that it should be able to track the bugs and make them easily available to the team that will continue on this project next year.
The tools that we are considering to use for bug tracking are Bugzilla \cite{bugzillaFeat} and Eventum \cite{eventumFeat}.
These tools are very similar in their sets of features.
When a bug is discovered a bug report must be added in the tool.
In the tools the members of a team can see the bugs and their status, and mark them as fixed when they are handled.

Since we have used Bugzilla as part of the course Test and Verification, it will save us the overhead of having to learn a new tool by select that over Eventum.
Furthermore, development of Eventum seem to be discontinued since the start of 2009 \cite{eventumDiscont}, which means that any defects that may be in the system are very unlikely to be fixed.
In conclusion we choose to use Bugzilla to track our bugs.

\subsection{Code Documentation}
%We want our documentation of our code to be as close to the code as possible.
%In particular we do not want to go back and forth between the source code and some other program when we are writing new functionality and documenting it.
We do not wish to use a tool that requires us to type in documentation externally from the code.
We want to use a tool like PHPDocumentor \cite{phpdocumentor} or PHPXref \cite{phpxref} to handle our documentation, since both of these read comments in the source code and use it as documentation.
This gives us the ability to write code and documentation in the same file.
The syntax that both of these tools use is the same, which means that as long as we adhere to this syntax we can use either tool to generate documentation.

The difference between the two tools is that the focus of PHPDocumentor is on giving a more diverse set of final documents (different HTML and PDF templates), where the focus of PHPXref is more on the reference between classes, function, etc.
We use both tools such that we and the group that is to take up this project next year can choose the documentation they prefer.


\subsection{Testing}
\label{sub:testing}
The test tool that we want to use should be easily adapted to our needs, which leads us to look at tools using PHP, since that is the language we will be using to develop this project.
We also want the tests to survive after our work on the project ends, in particular the groups that is to take up this project next year should be able to use our test cases again.
We will be using the build in testing framework of Moodle \cite{moodletest}, which is based on SimpleTest \cite{simpletest}.
This should ensure that the test cases can be used next year as well and perhaps be part of the final product, should it be released to the public.


